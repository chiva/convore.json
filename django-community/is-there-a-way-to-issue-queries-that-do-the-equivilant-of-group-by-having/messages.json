[{"user_id": 3580, "stars": [], "topic_id": 39337, "date_created": 1308066844.917012, "message": "Is there a way to do that via the ORM?", "group_id": 81, "id": 1391971}, {"user_id": 3580, "stars": [], "topic_id": 39337, "date_created": 1308066796.6352141, "message": "When I want to query say... all of the distinct Authors that have published at least two books this year..", "group_id": 81, "id": 1391968}, {"user_id": 3580, "stars": [], "topic_id": 39337, "date_created": 1308066770.7393219, "message": "It doesn't seem so, but I'm getting a bit tired of running for SQL whenever I hit this condition so I figured I'd ask...", "group_id": 81, "id": 1391964}, {"user_id": 3580, "stars": [], "topic_id": 39337, "date_created": 1308066830.2776251, "message": "SQL would be something like 'select distinct author_id from book group by author_id having count(*) >= 2'", "group_id": 81, "id": 1391969}, {"user_id": 30035, "stars": [], "topic_id": 39337, "date_created": 1308067759.9772201, "message": "You just beat me to linking that, but I hadn't checked whether it generates efficient SQL with HAVING. Did you confirm that?", "group_id": 81, "id": 1392074}, {"user_id": 3580, "stars": [], "topic_id": 39337, "date_created": 1308067397.3713169, "message": "Ooooh. I finally found it!  https://docs.djangoproject.com/en/dev/topics/db/aggregation/#filtering-on-annotations", "group_id": 81, "id": 1392034}, {"user_id": 3580, "stars": [], "topic_id": 39337, "date_created": 1308067785.7891791, "message": "yeah, I just did.. it does in fact generate the HAVING SQL instead of just doing some sort of post-filtering.", "group_id": 81, "id": 1392078}, {"user_id": 3580, "stars": [], "topic_id": 39337, "date_created": 1308067792.0844769, "message": "pretty clever.", "group_id": 81, "id": 1392080}]