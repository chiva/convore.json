[{"user_id": 15365, "stars": [], "topic_id": 8394, "date_created": 1298491505.79969, "message": "it's just not creating dependancies inside your methods, but passing them as arguments.", "group_id": 160, "id": 190491}, {"user_id": 5711, "stars": [{"date_created": 1298506781.5501249, "user_id": 14356}], "topic_id": 8394, "date_created": 1298493611.5708339, "message": "This is not really answering your question but this helped me out a bit when I got caught up in terminology: http://loosecouplings.blogspot.com/2011/01/dependency-injection-using-di-container.html", "group_id": 160, "id": 190875}, {"user_id": 14356, "stars": [], "topic_id": 8394, "date_created": 1298596823.3595459, "message": "After reading through many articles, I find that DI is \"giving an object its instance variables\".", "group_id": 160, "id": 204752}, {"user_id": 8327, "stars": [], "topic_id": 8394, "date_created": 1298626852.436687, "message": "DI seems to just be a rebranding of something that's been in OO for ages, hell I was writing \"DI\" db stuff half a decade ago! This is slightly disappointing, I was hoping for something a little more revolutionary", "group_id": 160, "id": 206839}, {"user_id": 14356, "stars": [], "topic_id": 8394, "date_created": 1298637587.606463, "message": "@mal give an example of what you have in mind.", "group_id": 160, "id": 207480}, {"user_id": 12269, "stars": [], "topic_id": 8394, "date_created": 1298645976.401581, "message": "DI is the pattern of providing dependencies to an object rather than having it create them. The goal is a loosely coupled design. Essentially, you are not using constructors in the injected class.  Often, an IoC container is used to resolve these dependencies. With prototypal inheritance, you are probably already constructing objects this way.", "group_id": 160, "id": 208318}, {"user_id": 8327, "stars": [], "topic_id": 8394, "date_created": 1298646993.1858101, "message": "@jkelkar something to the effect of:\n\ninterface Log // logging api\nclass FileLog implements Log // Generic logging class, logs to file system\nclass MySQLDBA // direct dbaccess requires a Log\nclass DBAFactory // static method instanciating MySQLDBA passing FileLog\nclass Main // $db = DBAFactory::getDB()", "group_id": 160, "id": 208495}, {"user_id": 14356, "stars": [], "topic_id": 8394, "date_created": 1298668951.3313861, "message": "@mal Can I rephrase that is \"don't guess\" where your support is coming from , know it for sure by creating an instance of the support object?", "group_id": 160, "id": 211400}, {"user_id": 1516, "stars": [], "topic_id": 8394, "date_created": 1298715367.348098, "message": "well, kinda", "group_id": 160, "id": 213633}, {"user_id": 1516, "stars": [], "topic_id": 8394, "date_created": 1298715346.161469, "message": "non-DI: function query(dbURL, query) { var conn = new MySQLConnection(dbURL); return conn.query(dbURL); }", "group_id": 160, "id": 213628}, {"user_id": 1516, "stars": [], "topic_id": 8394, "date_created": 1298715365.219162, "message": "DI: function query(conn, query) { return conn.query(query); }", "group_id": 160, "id": 213631}, {"user_id": 1516, "stars": [], "topic_id": 8394, "date_created": 1298715371.0530541, "message": "not the best example", "group_id": 160, "id": 213634}, {"user_id": 8327, "stars": [], "topic_id": 8394, "date_created": 1298735632.8419681, "message": "@jkelkar The idea in my example is that Main doesn't know (or care) about the Log that gets used, it just wants an (interface) DBA object. By making it depend only on the factory and the DBA interface, we've removed the need for hard binding. We can have the factory produce any DBA and Main will just get on with it", "group_id": 160, "id": 214459}, {"user_id": 8327, "stars": [], "topic_id": 8394, "date_created": 1298735813.4334199, "message": "@judofyr's example may be easier to understand; we don't care what the exact type of conn is, only that it provides the methods we're expecting, thus there's no explicit dependency on the MySQLConnection class, we have in effect, injected the dependency!", "group_id": 160, "id": 214467}, {"user_id": 8490, "stars": [], "topic_id": 8394, "date_created": 1298894839.9980619, "message": "What I understand is that you don't hardcode your dependencies. That way it's easier to test and make changes.", "group_id": 160, "id": 225086}, {"user_id": 20744, "stars": [], "topic_id": 8394, "date_created": 1300365784.7909031, "message": "A typical JavaScript example is you want to look things up from a live server in production, but from a dummy (simulation) data store object during development, so everything happens in the browser. Most developers would do some quick-and-dirty commenting and uncommenting to make this happen, but it would be better if there was a separate \"production\" configuration and a \"development\" configuration.The \"production\" configuration, in conjunction with a Dependency Injection framework, would set things up so that things requiring a data store will use a 'NetworkedDataStore'. e.g. the config would say to the effect \"whenever you create an object that needs a data store, give it a \"NetworkedDataStore\" '. Whereas the \"development\" configuration would always make it a local data store (And you could have any number of other configs.)", "group_id": 160, "id": 373422}]