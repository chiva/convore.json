[{"user_id": 33307, "stars": [], "topic_id": 35345, "date_created": 1305444776.8523259, "message": "Hmm, my GCC is fine with that. I wonder what happens.", "group_id": 9610, "id": 1058310}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305440900.0133779, "message": "would it be evil to want a unary <, <=, or << that did std::move? some_func(<param);", "group_id": 9610, "id": 1057976}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305442350.5946641, "message": "what other wacky or crazy ideas about c++ do you guys have? (hey, cut me some slack, I'm trying to kickstart this c++ group... ;)", "group_id": 9610, "id": 1058034}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305444164.4733109, "message": "std::forward requires a template parameter so it can determine (through overload resolution) the correct type", "group_id": 9610, "id": 1058266}, {"user_id": 33307, "stars": [], "topic_id": 35345, "date_created": 1305444784.344892, "message": "GCC 4.5 btw.", "group_id": 9610, "id": 1058311}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305445290.0289021, "message": "@jabberwockslayer the reason it can't deduce is it must already know T in order to pick the right specialization of the template, so it can get ::type out; it's a circular dependency", "group_id": 9610, "id": 1058349}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305444367.9343979, "message": "I'm not opposed to an operator for std::forward (if one was added for std::move, which I'm unsure about), but I'm not sure how to easily incorporate that template parameter", "group_id": 9610, "id": 1058275}, {"user_id": 33307, "stars": [], "topic_id": 35345, "date_created": 1305443933.7575891, "message": "If we did that, I'd want one for std::forward as well. You said something about requiring a parameter. I didn't understand.", "group_id": 9610, "id": 1058246}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305444881.4279771, "message": "template <class T> T&& forward(typename remove_reference<T>::type& t) noexcept;\ntemplate <class T> T&& forward(typename remove_reference<T>::type&& t) noexcept;\n", "group_id": 9610, "id": 1058316}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305445363.655767, "message": "which disables type deduction: template<class T> void f(typename identity<T>::type);", "group_id": 9610, "id": 1058368}, {"user_id": 33307, "stars": [], "topic_id": 35345, "date_created": 1305446794.5718479, "message": "Did you see @sbi's argument? \"std::move() we can always abandone (who's using std::set_terminate() these days?), but an operator we're stuck with, and it will always interfere with other code.\"", "group_id": 9610, "id": 1058458}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305444438.1029689, "message": "I do like the look of something applying direction \"into\" something else for moves though ;)", "group_id": 9610, "id": 1058280}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305444894.745558, "message": "it should not be able to deduce T from those declarations", "group_id": 9610, "id": 1058318}, {"user_id": 33307, "stars": [], "topic_id": 35345, "date_created": 1305444055.123786, "message": "In any case, I'm not sure overloading an existing operator is a good idea.", "group_id": 9610, "id": 1058260}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305444471.3742521, "message": "return <obj; Ctor(T v) : data(<v) {}", "group_id": 9610, "id": 1058283}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305444497.3987, "message": "@jabberwockslayer using std::forward(x) is an error, you *must* give a type to make it useful", "group_id": 9610, "id": 1058286}, {"user_id": 33307, "stars": [], "topic_id": 35345, "date_created": 1305445810.1825571, "message": "Sometime it requires the parameter, sometimes it's ok. I'm trying to isolate a couple of test cases.", "group_id": 9610, "id": 1058420}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305444179.413475, "message": "it relies on reference collapsing", "group_id": 9610, "id": 1058267}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305444193.290462, "message": "std::forward<T>(obj)", "group_id": 9610, "id": 1058269}, {"user_id": 33307, "stars": [], "topic_id": 35345, "date_created": 1305444462.48563, "message": "The same way you can elide it when using std::forward? Just make std::forward(x) the same as @x, whatever @ you pick for the operator.", "group_id": 9610, "id": 1058282}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305444702.9432321, "message": "actually, given how it's defined, I think std::forward(x) without a type should be a flat-out compile error", "group_id": 9610, "id": 1058303}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305447108.2401171, "message": "the solution to that one is to actually use an initializer list, I believe: auto a = {...}", "group_id": 9610, "id": 1058473}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305447121.4500711, "message": "an std::initialize_list*, that is", "group_id": 9610, "id": 1058477}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305446767.7178171, "message": "no, it was a good idea :) I thought about it at first too", "group_id": 9610, "id": 1058451}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305446787.366164, "message": "as in, \"if we're going to do this with std::move, what else...\"", "group_id": 9610, "id": 1058455}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305444870.326086, "message": "I'm looking at 20.2.3 in the latest draft", "group_id": 9610, "id": 1058315}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305445342.1456621, "message": "this was pointed out to me with template<class T> struct identity { typedef T type; };", "group_id": 9610, "id": 1058361}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305445868.513411, "message": "it could be something that needs to be chalked up to incomplete/buggy 0x support", "group_id": 9610, "id": 1058432}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305446944.303556, "message": "I don't see any serious problems for parsers, which, remember, already know how to handle stuff like A<B>>C; (which is either a nested template or an (A<B) >> C expression)", "group_id": 9610, "id": 1058467}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305446972.68647, "message": "variable of a type that's a nested template*", "group_id": 9610, "id": 1058468}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305447006.7069681, "message": "@jabberwockslayer just some beauty and a few keystrokes? have you heard of FORTRAN and COBOL? :)", "group_id": 9610, "id": 1058469}, {"user_id": 33307, "stars": [], "topic_id": 35345, "date_created": 1305445831.1156819, "message": "From those definitions I agree it shouldn't deduce it.", "group_id": 9610, "id": 1058425}, {"user_id": 33307, "stars": [], "topic_id": 35345, "date_created": 1305446706.973134, "message": "(I'll see if I can isolate a test case for a report.) Ok, forget std::forward.", "group_id": 9610, "id": 1058450}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305446838.7328639, "message": "yeah, he tweeted me a link to it", "group_id": 9610, "id": 1058461}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305446871.7023709, "message": "there is no unary <, <=, or << (I'm open to other suggestions, but I like the directionality those have, as I said), so I'm not sure how it'd interfere", "group_id": 9610, "id": 1058463}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305447167.7617309, "message": "but that works mostly because initializer_list was given its own syntax, even if it reused braces", "group_id": 9610, "id": 1058484}, {"user_id": 33307, "stars": [], "topic_id": 35345, "date_created": 1305446900.733391, "message": "The way I see it, we already have a working solution, and it expresses the intent quite clearly. We would add yet another symbol, just to gain some beauty and save a few keystrokes.", "group_id": 9610, "id": 1058466}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305447047.0714309, "message": "how many people will continue to use T a[] = {...}; instead of std::array<T, /*uh-oh, now we have to count*/> a = {...};", "group_id": 9610, "id": 1058470}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305447057.2014141, "message": "even though std::array is superior in every way", "group_id": 9610, "id": 1058471}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305447184.8094599, "message": "(though it's UB if you don't include a right header before using it)", "group_id": 9610, "id": 1058486}, {"user_id": 33307, "stars": [], "topic_id": 35345, "date_created": 1305447820.3148611, "message": "Ok, I think I probably can agree it wouldn't be evil. I wouldn't mind having it, but personally, I'm happy with std::move.", "group_id": 9610, "id": 1058548}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305448036.7832589, "message": "I know us c++ programmers love library solutions, but sometimes I think we lean on them too much :(", "group_id": 9610, "id": 1058575}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305449727.9245911, "message": "@jabberwockslayer: actually, as long as we're inventing syntax, it might be possible to implement this operator so it could work as std::forward", "group_id": 9610, "id": 1058692}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305448006.7714479, "message": "someone I know on irc once wrote/modified a parser (it actually parsed SPECS or something like that) that emitted c++, wrapping string literals as std::strings among other changes", "group_id": 9610, "id": 1058572}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305448046.5836539, "message": "and that's kinda what got me thinking about this", "group_id": 9610, "id": 1058581}, {"user_id": 31883, "stars": [], "topic_id": 35345, "date_created": 1305449774.0773571, "message": "by somehow inspecting the declared type of a variable, when < is applied to a variable, and falling back to std::move when it's applied to an expression", "group_id": 9610, "id": 1058693}]