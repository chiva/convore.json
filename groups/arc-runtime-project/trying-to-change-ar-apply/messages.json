[{"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305063378.77632, "message": "Okay, so, I'm trying to change it so when ar sees a hash table in functional position, it will do something special, rather than the normal hash-ref thing. Just extend ar-apply, right? Nope, doesn't work. Using a `let` to store the original value of ar-apply, and then trying to overwrite it doesn't work either... at this point it seems my best bet is to modify ar.ss directly, which I'd rather not do.", "group_id": 9739, "id": 996422}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305063455.0973721, "message": "Oh, and for the record, I'm trying to do this in a Racket file, not from within Arc. If there's some magic incantation to make this work, I'd like to hear about it.", "group_id": 9739, "id": 996432}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305064513.115355, "message": "Oh, you're right.  The problem here is that \"extend\" in Racket works in the Arc namespace.  It's not a solution that I like anyway, because I want ar to be hackable in Arc... and not that I usually pay a lot of attention to performance, but I imagine that checking for hashes first before functions is going to slow things down a lot.\n\nA general facility might be a \"post extend\", which would plug in after a built in function had run through its defaults, but just before it throws its error saying \"don't know how to foo\".  But, that wouldn't work here either, since ar-apply would do its default action of looking up a value in the hash.\n\nOff the top of my head, I can think of two ideas:\n\n- we could have a function to call to set what ar-apply should do to when it see a hash.\n\n- ar-apply, when it sees a hash, could call an Arc function to do the operation.  You could then redefine that Arc function to do what you want instead.", "group_id": 9739, "id": 996562}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305063648.8277111, "message": "Also, before you ask, here's what I've tried so far:\n\n(let ((orig ar-apply))\n  (define (ar-apply fn . r/args)\n    (cond ((hash? fn) (display fn) 'nil)\n          (else (apply orig fn r/args))))\n  'nil)\n\n(extend ar-apply (fn . r/args) (tnil (hash? fn))\n  (display fn)\n  'nil)", "group_id": 9739, "id": 996463}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305063943.527221, "message": "extend wouldn't work, even if ar-apply were reflected into the Arc namespace.  The problem is that the test function written in Arc (the \"(hash? fn)\") would itself be calling ar-apply, and so you'd get into an infinite loop.", "group_id": 9739, "id": 996520}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305064886.774323, "message": "- ar-apply would do just enough to get the compiler off the ground.  Just checking for functions might be enough.  So perhaps it could first check for a function, and if it wasn't a function, it could call an Arc function to handle it.  I think maybe Anarki has something similar where calling something causes it to be coerce'd to a function (and the coercion can can be overridden) and then the resulting function is called.", "group_id": 9739, "id": 996646}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305064921.6619799, "message": "ok", "group_id": 9739, "id": 996655}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305066877.246937, "message": "ac.ss calls ar-funcallX which calls ar-apply.  So one way would be to add the extra argument to the ar-funcallX functions, call the ar-funcallX function from ac.ss with the extra argument (which does have access to the global namspace, and so can use it to lookup the function to use), and then have the ar-funcallX functions pass the argument to ar-apply.", "group_id": 9739, "id": 996968}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305063877.6432641, "message": "And also before you ask: using let has no effect, it's essentially ignored. Using extend fails with the error \"ar-apply is not defined\", which I presume is because ar-apply isn't exposed to Arc.", "group_id": 9739, "id": 996504}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305064067.5200689, "message": "Except the test function isn't written in Arc. This is in Racket, and tnil/hash? aren't Arc functions, so I don't see where it's calling ar-apply.", "group_id": 9739, "id": 996531}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305066226.7449889, "message": "Okay, so coerce *is* exposed to Arc, so I can use extend on that... so my plan is that when ar-apply sees something that's not a function, it tries to coerce it to a function. Then, I can extend coerce to do what I like with hash tables.\n\nIn my particular case, this should actually be pretty efficient, though it'll likely slow things down a bit in general, because it has to create/destroy functions every time you put a non-function in functional position. So just something to keep in mind for optimizing later.\n\nJust one problem. ar-apply needs to get the current version of coerce, not the version of coerce that is defined in ar.ss... In ac.ss you would use (g ...) to do that, but ar.ss doesn't have access to that. Any ideas?", "group_id": 9739, "id": 996862}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305066713.3842859, "message": "Or to put it another way: how does ar.ss grab values from the Arc namespace?", "group_id": 9739, "id": 996947}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305067928.3026111, "message": "Yup, just getting it to work any which way is the first step.  We can figure out how to make the code less convoluted afterwards. :)", "group_id": 9739, "id": 997163}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305066607.561774, "message": "Yeah, okay, but my question is: how does that function get the current version of coerce? I can't just use arc-coerce since that's going to be overwritten by Arubic.", "group_id": 9739, "id": 996929}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305064902.434324, "message": "Either sounds okay, as long as it *works*. I'm just trying to get a super-minimal Arubic working, and this is the first natural step, since I intend all (or at least some...) compound data to be represented as hash tables.\n\nI'll try hacking ar to get something similar to \"defcall\" implemented. I'm not worried about efficiency right now.", "group_id": 9739, "id": 996650}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305066488.9836669, "message": "I imagine right now the easiest thing to do would be to add an additional argument to ar-apply: a function to call if it doesn't handle it itself.  Don't worry about it being awkward, I'll be happy to refactor once you get something working.", "group_id": 9739, "id": 996906}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305067790.3004529, "message": "Okay, that seemed to work, though calling (apply ...) in Arc doesn't work now. Which is because arc-apply doesn't have access to the current version of coerce either... but at least ordinary calling works. I'll see if I can hack in support for Arc's apply.", "group_id": 9739, "id": 997135}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305066610.117672, "message": "The separation of code between ar.ss and ac.ss is rather artificial anyway; it's left over from when I thought I was going to write an Arc implementation language in Racket.", "group_id": 9739, "id": 996931}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305066962.725841, "message": "Which will of course slow things down because we'll be doing the extra lookup for each procedure call, but we can moving things around once something is working.", "group_id": 9739, "id": 996983}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305068107.1050439, "message": "Oh, but now (apply ...) doesn't work with my custom coercion rules... ugh. Oh well, this should be enough to at least get started on Arubic.", "group_id": 9739, "id": 997211}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305068174.8733771, "message": "Cool!  When it makes sense to do so, you could make a branch with your changes and a test or two that demonstrates that a custom behavior for hash tables can now be defined, and I can work on making it less clunky.", "group_id": 9739, "id": 997224}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305067989.695709, "message": "Okay, got that to work too. Phew. Clunky, but it works. And now I can define custom behavior for hash tables in Arubic.", "group_id": 9739, "id": 997180}, {"user_id": 32877, "stars": [], "topic_id": 34644, "date_created": 1305083908.358947, "message": "This is also one of my new start.", "group_id": 9739, "id": 1000752}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305147553.813174, "message": "I almost got the tests for (coerce foo 'fn) done. They're written with my handy-dandy custom test library, which I'll explain in another post.", "group_id": 9739, "id": 1014311}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305148355.989011, "message": "Aaand I just got bit by fn being special-cased in ac... I tried to make a local variable (using let) called \"fn\", which of course failed... with a cryptic error. Why are they special-cased, again?", "group_id": 9739, "id": 1014502}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305152230.171289, "message": "For shadowing, I imagine that might be done by adding code to the compiler to check for the form being used as a lexical variable in all cases.  For overwriting, that can be done now by extending ac... or, special forms could all be macros, but then they'd need to expand into *something*, and that something would then need to be treated specially by the compiler and we'd be back to where we started in terms of how to make them overwritable.  Unless perhaps we decided that for example that quote would be a macro that expanded into %%internal-quote or something, and it was ok for %%internal-quote to not be a macro itself.", "group_id": 9739, "id": 1015424}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305151384.1916161, "message": "By the way, ideally *all* of ac's special forms (fn, quote, etc.) would allow overwriting/shadowing, so I'm just noting that fn is a particularly bad case due to it's shortness.", "group_id": 9739, "id": 1015298}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305150723.991055, "message": "Hmm, well, we need *some* mechanism for turning a \"fn\" into a Racket lambda.  You could add code to the compiler to check if \"fn\" is a lexical variable in the environment and not turn it into a lambda in that case.  We could treat \"fn\" as a macro, I suppose, and have it expand into \"racket-lambda\", but then we'd need to tell the Arc compiler that \"racket-lambda\" was special, and if we wanted to be able to use racket-lambda as a lexical variable we'd have the same issue as we have now with fn.  Though I suppose... if had a list of racket forms that the compiler should emit as-is that might be a cleaner solution.", "group_id": 9739, "id": 1015137}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305151048.1496699, "message": "Either of those sounds okay to me. The problem with special-casing fn is that A) it's short, I like short variable names, and B) it's a perfectly reasonably variable name for a function that expects a function.\n\nYou're pretty unlikely to trip up over quote, quasiquote, etc. but fn seems pretty trip-worthy to me. Doing a lexical check (like how macros work right now) sounds pretty good to me.", "group_id": 9739, "id": 1015209}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305153366.4087989, "message": "\"fn\" could be a macro that expands into a value, but there's no value that Racket will accept as a Racket lambda aside from a symbol (whatever we named lambda on import).  Though we could use a globally unique name for the symbol (such as \"lambda%beKL85Na\") that couldn't be used by accident.", "group_id": 9739, "id": 1015690}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305153680.3640151, "message": "Wait, so this wouldn't work? `',(lambda ...) From within Racket, of course. I'll note that my \"racket\" macro can return lambda forms: (racket (lambda ...)) despite it being an Arc-style macro.", "group_id": 9739, "id": 1015734}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305152667.838732, "message": "There's no mechanism in Racket to treat a Racket macro or special form like \"lambda\" as a value, as far as I know.", "group_id": 9739, "id": 1015583}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305152966.6713059, "message": "Except... I don't think I did that. Sounds like a bug.", "group_id": 9739, "id": 1015652}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305152776.9489319, "message": "What about Arc macros? I put ac-mac-fn into ac.ss, remember? So couldn't it be an Arc-style macro that expands into a Racket value?", "group_id": 9739, "id": 1015614}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305153182.728188, "message": "https://convore.com/feedback/", "group_id": 9739, "id": 1015672}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305152491.0200119, "message": "By \"overwriting\" I mean stuff like (= fn ...) which doesn't work right now. By the way, why not have the macros expand into values? Like fn could expand into a Racket lambda or whatever.\n\nAs for how to handle quote... you could make it an internal value, as you said, and have it expand into that. The internal value could even be a gensym, making conflicts between Arc/Racket impossible.", "group_id": 9739, "id": 1015528}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305152808.9517059, "message": "Also, I have no clue how I made my earlier post appear inside a <pre> tag... which is pretty annoying since I don't think I did anything special, and now I'm curious so I can know how to trigger it on purpose.", "group_id": 9739, "id": 1015623}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305152924.7279761, "message": "If the input box is empty, you paste plain text from your clipboard into the input box, and you don't change it (that is, you submit pasted text and nothing else), convore renders it pre.", "group_id": 9739, "id": 1015645}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305153076.209203, "message": "Thanks for the info, though. I kinda wish they had a way to specify \"this blob of text should be rendered in pre\" kinda like the Arc forum, or Google Code.", "group_id": 9739, "id": 1015661}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305154269.307199, "message": "Yeah, I'll try my idea out soon. See if it works. It's the same idea as the \"racket\" macro, though, so I don't see why it wouldn't.", "group_id": 9739, "id": 1015794}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305156035.9197481, "message": "I could just put it into a global variable, which would cause a new assignment every time ac is run... or maybe I could use a dynamic variable?", "group_id": 9739, "id": 1015970}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305154201.801532, "message": "If you have an Arc macro (whether defined in Racket or not) that expands into \"(lambda ...)\", the Arc compiler will generate a call to lambda as if it were a function, because \"lambda\" isn't an Arc macro or a special form recognized by the compiler.  If you have a macro that expands into \"(racket (lambda ...))\" then the sub-forms of the lambda won't be compiled.  But do feel free to try out ideas, the good news is that with the unit tests it's usually pretty easy to tell when something isn't working.", "group_id": 9739, "id": 1015784}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305154081.544992, "message": "I'll also note that the \"racket\" macro lambdas can be used like Arc functions: ((racket (lambda (x) x)) 'a) So I don't see why you couldn't use a similar technique for \"fn\"", "group_id": 9739, "id": 1015770}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305154351.6248951, "message": "By the way, due to lexical scope, I'm pretty sure my technique bypasses the entire Arc compiler, and just uses raw Racket. So I think using (lambda ...) will work, because of that. We shall see.", "group_id": 9739, "id": 1015804}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305156445.4080801, "message": "Yes, the \"fn\" macro. Which returns the value of ac-fn. Also it would be useful in other situations. There's a reason I'm putting (current-env) into Arubic, after all. :P", "group_id": 9739, "id": 1016024}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305157167.201385, "message": "Kay. Actually, since I just realized ac-mac-call has access to the environment... first I'm going to just use a global variable that'll be set in ac-mac-call. Once I get that working (with tests, too) we can work on making it an implicit variable.", "group_id": 9739, "id": 1016138}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305155896.7678609, "message": "Aha! I just realized ac-fn needs access to the current environment... that's handled in Arubic with (current-env) but I don't think ar has a similar mechanism...", "group_id": 9739, "id": 1015953}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305156496.4609079, "message": "Sounds like it would be a good idea to invest in making env an implicit variable where macros can get at it then :)", "group_id": 9739, "id": 1016028}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305156129.7172029, "message": "Ugh... that's complicated by the fact that ac is extended. And the new extensions also need to assign the current environment as well...", "group_id": 9739, "id": 1015989}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305156406.7253749, "message": "You have a macro that needs to look at the current environment?", "group_id": 9739, "id": 1016023}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305156290.6066599, "message": "I would suggest adding env as another argument ac-fn for now.  I do think it might turn out that we'd like to  make env an implicit variable (it could be useful for macros as well), but that might be better to try out separately.", "group_id": 9739, "id": 1016013}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305156344.8176501, "message": "No, env already is an argument to ac-fn... that's not the problem. The problem is that the only way to get the current environment is to extend ac. Which we're trying to avoid.", "group_id": 9739, "id": 1016020}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305156521.0241041, "message": "Okay, great. Now, how do I do that?", "group_id": 9739, "id": 1016033}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305156978.0550139, "message": "ok, if there's an existing Racket parameter in Racket, you can make an implicit variable in Arc that references that parameter with make-implicit.  For example, \"(make-implicit stdin  racket-stdin)\".  So as a first step what I'd do is create a Racket parameter called something like \"racket-ac-env\", and in ac-mac-call where it calls arc-apply on the macro procedure m, parameterize racket-ac-env to env.  You'd also need to inject racket-ac-env into the Arc namespace, and then in Arc you can use \"(make-implicit ac-env racket-ac-env)\".\n\nLater we could change all references to \"env\" to use the parameter so that it no longer needed to be passed around, but this would be good enough to get working first.", "group_id": 9739, "id": 1016107}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305157185.2754569, "message": "Sounds good.", "group_id": 9739, "id": 1016140}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305161076.9196119, "message": "Alternatively, you could use Arubic's approach and represent functions as hash tables, but then you'd lose compatibility with Racket, I think.", "group_id": 9739, "id": 1016645}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305161492.0619509, "message": "So your fn macro expands into (racket-lambda ...) ?", "group_id": 9739, "id": 1016685}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305161374.460202, "message": "Well, in ac... when it sees 'fn it just returns ((g ac-fn) (arc-cadr s) (arc-cddr s) env) So I figured, why not write an Arc macro that returns that? Problem is, I then get the error \"expected procedure, given: racket-lambda;\"", "group_id": 9739, "id": 1016666}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305161277.66523, "message": "I don't understand how having fn be a function that returns value would work anyway.", "group_id": 9739, "id": 1016659}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305161723.1626279, "message": "Also there is no value in Racket for the value of racket-lambda.", "group_id": 9739, "id": 1016703}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305161800.9652319, "message": "Yeah, I kinda figured that out. Which is pretty unfortunate, since having everything first-class is useful, I think.", "group_id": 9739, "id": 1016713}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305161888.2247081, "message": "Yes, it would be very nice if Racket macros and special forms could be used from Arc, and I've made some experiments in that direction, but don't have anything working yet.  (We'd need macro expansion to be done by Racket's macro expander instead of in the Arc compiler).", "group_id": 9739, "id": 1016722}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305160987.4196911, "message": "Okay, I made some progress, but now I'm not sure how to continue. Have you considered adding fexprs into ar? Then fn could be a fexpr. That would probably be a lot easier than trying to write a macro that returns values.", "group_id": 9739, "id": 1016636}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305161410.940387, "message": "Which is weird, since racket-lambda should be defined in the Arc namespace.", "group_id": 9739, "id": 1016672}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305161556.1108439, "message": "Yeah, basically. I'd rather it expand into the *value* of racket-lambda... but I'll settle for that right now. racket-lambda isn't prime real estate, but fn is.", "group_id": 9739, "id": 1016690}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305161623.0596721, "message": "Okay, made some more progress. I might be able to make this work...", "group_id": 9739, "id": 1016693}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305162112.924314, "message": "If you renamed \"fn\" in ac.ss to \"%%internal-fn\" and made fn a macro that expanded into %%internal-fn, how would that not do what you want?  (I'm not saying it would, I'm just wondering what else you'd like it to do).", "group_id": 9739, "id": 1016751}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305161674.2743609, "message": "The Arc compiler will compile (racket-lambda ...) into (ar-apply racket-lambda ...)", "group_id": 9739, "id": 1016700}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305162764.101042, "message": "I haven't worried about name conflicts anywhere else in ar.", "group_id": 9739, "id": 1016852}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305162453.8340831, "message": "Yeah, that's a pretty good idea as a last resort. Ideally, what I'm trying to do is get it to expand into a value, but I don't think that'll work because although lexical scope allows me to create Racket lambdas, those lambdas don't have access to Arc's lexical scope...\n\nIt would probably be possible to change things around so that what I described above could work, but that would probably require a lot of effort, so I guess I'll just go with %%internal-fn (or similar) for now.", "group_id": 9739, "id": 1016818}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305162518.040658, "message": "Actually, we could have it expand into a gensym, if we were really worried about name conflicts.", "group_id": 9739, "id": 1016826}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305162782.226723, "message": "By the way, if we went that route (expanding into a gensym/obscure name) it would give us 99% of the value of making fn first-class. It should also allow us to shadow/overwrite fn, since it's just an ordinary macro. That's acceptable to me, at least for now.", "group_id": 9739, "id": 1016856}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305163373.5559051, "message": "And it works. I'm using gensyms, but I designed it so it's trivial to change it to an obscure name, if you prefer.", "group_id": 9739, "id": 1016973}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305163510.684118, "message": "I also designed it so it's possible to generalize it to other things, like quote, quasiquote, etc. But I haven't done that yet. A macro would help make the boilerplate easier to digest.", "group_id": 9739, "id": 1017001}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305163541.0933001, "message": "I think it would be better for consistency for now; everywhere else we have Arc forms expanding into more primitive forms simply by their name.", "group_id": 9739, "id": 1017009}, {"user_id": 25438, "stars": [], "topic_id": 34644, "date_created": 1305163108.132916, "message": "Sounds good to me.  I've so far been using the \"more obscure name\" approach.  I'm also interested in using globally unique identifiers for this kind of thing, but I think that would be better done as a separate step so that it could be applied uniformly.", "group_id": 9739, "id": 1016912}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305163719.4993329, "message": "Yeah, but the whole reason for this is to allow for overwriting/shadowing stuff, so we can pretend that things like fn are first class, rather than hardcoded into ac. I'll probably want to shadow quasiquote in Arubic, for instance. But you're right, we can do that later. This change should allow me to define fn in Arubic, huzzah.", "group_id": 9739, "id": 1017049}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305163990.7054279, "message": "Alright, the change is on my fork. Now to write some tests to verify it...", "group_id": 9739, "id": 1017102}, {"user_id": 32943, "stars": [], "topic_id": 34644, "date_created": 1305219949.9812801, "message": "Guess I'm a bit late in mentioning this, but I've thought to myself that ar could special-case the 'racket-mac type instead of the 'mac type. A racket-mac would take both the Arc expression being expanded and the local static environment to expand it in (the list of locals), and it would return a Racket expression. Most (all?) Arc special forms would be racket-macs. There'd still be regular Arc macros, but they'd be implemented on the Arc side.", "group_id": 9739, "id": 1026435}, {"user_id": 32943, "stars": [], "topic_id": 34644, "date_created": 1305220342.885071, "message": "Consider, though, that even if a local variable can be named \"fn\" and shadow the normal 'fn, that's almost always going to horribly break any unhygienic macros in the scope. Of course, once a macro uses something like `(,latemac.fn () ...) to be hygienic, it should be fine. http://arclanguage.org/item?id=14521", "group_id": 9739, "id": 1026479}, {"user_id": 32737, "stars": [], "topic_id": 34644, "date_created": 1305235089.5649879, "message": "Yeah, I'm not worried about that. That's the same problem with variable capture with *any* unhygienic macros. Hygienic macros shouldn't have that problem.\n\nSo that's like saying, \"if you use let to bind the variable = then it'll break stuff!\" Well, yeah. Duh. The ability to overwrite/shadow fn is definitely a win, I think, despite unhygienic macros.", "group_id": 9739, "id": 1030120}]