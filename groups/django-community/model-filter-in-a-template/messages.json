[{"user_id": 214, "stars": [{"date_created": 1298161865.8065259, "user_id": 1}], "topic_id": 7547, "date_created": 1298161299.679296, "message": "@Samuirai If it's a business-logic calculation, something inherent in the domain model, make it a model method. If it's a presentational concern, make a template tag.", "group_id": 81, "id": 151447}, {"user_id": 927, "stars": [], "topic_id": 7547, "date_created": 1298161077.526649, "message": "or write a custom manager / method if you want to do something like \"author.books.in_print\"", "group_id": 81, "id": 151415}, {"user_id": 10074, "stars": [], "topic_id": 7547, "date_created": 1298161014.712172, "message": "Hello,\nis it possible, to have a filter in the template?\nIn the view I can write mymodel1.mymodel2.filter(name=\"foo\"), to get all mymodel2 with some specific values.\n(mymodel1 has a 1:n relationship with mymodel2).\nBut In my template, I want to show a list of all mymodel1, and if they have an mymodel2 with the name=\"foo\" i want to give some additional informations.\n\nAs I said, in the view I could do a loop and do a filter on all mymodel2.\nBut in the template I can't write .filter(name=\"foo\").\nIs there a Syntax for that?", "group_id": 81, "id": 151402}, {"user_id": 10074, "stars": [], "topic_id": 7547, "date_created": 1298161152.1826341, "message": "I also could loop in the template through all mymodel2 relations if there is one with the searched name, but I thought, there could be something more beautyfull", "group_id": 81, "id": 151421}, {"user_id": 927, "stars": [], "topic_id": 7547, "date_created": 1298161022.962065, "message": "No", "group_id": 81, "id": 151405}, {"user_id": 1, "stars": [], "topic_id": 7547, "date_created": 1298161045.1541359, "message": "You'll have to write a custom templatetag to do that much logic", "group_id": 81, "id": 151409}, {"user_id": 927, "stars": [], "topic_id": 7547, "date_created": 1298161045.4712119, "message": "You have two approaches:", "group_id": 81, "id": 151410}, {"user_id": 927, "stars": [], "topic_id": 7547, "date_created": 1298161049.3790729, "message": "Put it in a template tag", "group_id": 81, "id": 151411}, {"user_id": 1, "stars": [], "topic_id": 7547, "date_created": 1298161269.8804171, "message": "Iterating over all of mymodel2 relations and seeing if there's one with the searched name will not be good performance, depending on how many there are.  I'd recommend querying for the data in your view code, or creating a templatetag to get the data that you want.", "group_id": 81, "id": 151441}, {"user_id": 927, "stars": [], "topic_id": 7547, "date_created": 1298161128.090553, "message": "Ah, @ericflo is a little too fast ;)", "group_id": 81, "id": 151418}, {"user_id": 10074, "stars": [], "topic_id": 7547, "date_created": 1298161211.2244329, "message": "what do you suggest me, for the best performance or style?\nI don't know django that deep :)\nthanks for all your help", "group_id": 81, "id": 151428}, {"user_id": 927, "stars": [], "topic_id": 7547, "date_created": 1298161362.4278741, "message": "Was just about to write what @carljm said better - would only add that you might want to consider a library like django-ttag or django-native-tags if you've never written a template tag before and are somewhat new to Django in general", "group_id": 81, "id": 151453}, {"user_id": 10074, "stars": [], "topic_id": 7547, "date_created": 1298161597.096173, "message": "It has to do with some language issues. I want to provide diffrent languages. I can see what language the user has chosen. Then I have Product with diffrent descriptions in diffrent languages.\nSo If you chose german, and there is a german description, you can see this in the list.\nIf there is only an english one, you just can see, that this product exists but with a text \"no description in your language\".\nSome better solutions to do that?\nBut I will check the tag system. But I think I will do it with a method. It seems to be the best solutions, because when I open a product I have to check again, if there is a desciption in the language.", "group_id": 81, "id": 151470}, {"user_id": 927, "stars": [], "topic_id": 7547, "date_created": 1298161989.954179, "message": "Ah, yes, that's a common situation which is a bit tricky to handle.", "group_id": 81, "id": 151488}, {"user_id": 927, "stars": [], "topic_id": 7547, "date_created": 1298162050.4894819, "message": "You might want to look at django-modeltranslation for one approach to storing translated content: it creates <field>_<lang> properties so you can provide values for each translated language and then uses a little magic so obj.<field> returns the appropriate one for the active translation language", "group_id": 81, "id": 151496}, {"user_id": 927, "stars": [], "topic_id": 7547, "date_created": 1298163928.8188651, "message": "What it means is that {{ mymodel.description.title }} would return mymodel.description.title_en  when the english translation is active, mymodel.description.title_fr when the French translation is active, etc.", "group_id": 81, "id": 151592}, {"user_id": 927, "stars": [], "topic_id": 7547, "date_created": 1298163942.549149, "message": "It's a different structure: denormalized fields on one model rather than a relationship", "group_id": 81, "id": 151593}, {"user_id": 927, "stars": [], "topic_id": 7547, "date_created": 1298163973.182832, "message": "I believe there's another project which uses the approach of having a related model per language for translations but I have no experience with it", "group_id": 81, "id": 151594}, {"user_id": 927, "stars": [], "topic_id": 7547, "date_created": 1298164529.453274, "message": "django-localeurl might be handy: it automatically takes a path like /en/<remainder>, sets the langugage for that request (e.g. request.LANGUAGE_CODE and the active translation) to English and then treats the remainder as if the language was there", "group_id": 81, "id": 151616}, {"user_id": 927, "stars": [], "topic_id": 7547, "date_created": 1298164545.221436, "message": "So e.g. /en/product/1/ would be the same as /product/1/ on a non-translated site", "group_id": 81, "id": 151617}, {"user_id": 927, "stars": [], "topic_id": 7547, "date_created": 1298164586.95959, "message": "\u2026 and yes, agreed about wanting less logic in the templates. I think it's better anyway and you'll end up fighting Django's philosophy", "group_id": 81, "id": 151621}, {"user_id": 10074, "stars": [], "topic_id": 7547, "date_created": 1298163844.9656401, "message": "Can I do something like that in the template?\nI loop through a list of mymodel1s\n\n{{ mymodel.description_{{ lan }}.titel }}\nThat doesn't work, but is this probably possible? That it generated description_eng or description_ger, depends on the lan variable.", "group_id": 81, "id": 151590}, {"user_id": 10074, "stars": [], "topic_id": 7547, "date_created": 1298164236.648613, "message": "ah you relate it on the app you gave me. What I try atm is to figure it out on my self. Need to learn django. I don't want to be fast or something like that. I need to understand everything :D\nI just thought, if it could be possible to do something like i wrote.\nBut in the theory, how would the app recognize what my language is?\nAtm i check the url. /site/... -> default: 'eng', or /ger/site/... -> 'ger'\nI could now check in the template, if lan='eng' then do mymodel.description_eng otherwise do description.ger.\nBut i think its to much logic in the template.", "group_id": 81, "id": 151612}, {"user_id": 10074, "stars": [], "topic_id": 7547, "date_created": 1298164272.5420439, "message": "or do you think, thats ok, because it works? :P", "group_id": 81, "id": 151613}, {"user_id": 10074, "stars": [], "topic_id": 7547, "date_created": 1298164827.9228201, "message": "yes ok. That's what I use too.\nBut what is now the best way, to get the speific description depending on the language?\nI could write in my template: if lan=='eng' choose this, and if lan=='ger' use another.\nCan I write a template tag to do this more properly?\nCan I handle that with a model method? Is it possible to use method parameters in a template? If yes, how?", "group_id": 81, "id": 151631}, {"user_id": 927, "stars": [], "topic_id": 7547, "date_created": 1298165426.277313, "message": "I'd do it in your view", "group_id": 81, "id": 151666}, {"user_id": 927, "stars": [], "topic_id": 7547, "date_created": 1298165454.7688191, "message": "e.g. the view passes something like \"description\" into the template context after doing the obj.descriptions.get(lang=\"eng\")", "group_id": 81, "id": 151668}, {"user_id": 10074, "stars": [], "topic_id": 7547, "date_created": 1298165624.832505, "message": "that works if i want to show the description from one particular product.\nBut I want to have a list with all products. And if there is a description in their language, you can see that in this list.", "group_id": 81, "id": 151678}, {"user_id": 12817, "stars": [], "topic_id": 7547, "date_created": 1298294763.9122541, "message": "@Samuirai If you can't do it in the view, another idea is to write a custom template tag that takes two arguments, the object the description belongs to and the language code, and outputs the description if it exists or \"no description in your language\" if it doesn't. That way, your logic's out of the template, and if you ever add a language later on that's 1 line you have to change (or even none, depending on how you write it).", "group_id": 81, "id": 158592}]