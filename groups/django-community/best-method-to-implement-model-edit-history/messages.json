[{"user_id": 3705, "stars": [], "topic_id": 20946, "date_created": 1303533058.391494, "message": "Another problem is the slug. If the slug is editable, urls will have to be versioned with appropriate constaints in place to make sure urls (even old ones) are unique. If the urls is: weblog/2011/04/23/the-slug then the constraint would have to be on the publsihed date and the slug. Otherwise old links won't work for redirection (there may be two+ identical urls).", "group_id": 81, "id": 787219}, {"user_id": 3705, "stars": [], "topic_id": 20946, "date_created": 1303532910.2309949, "message": "Ok, I have come across a few. What about optimistic locking to gaurd against concurrent editing? Easy enough to have a exclusive write lock on the table with all queries in a single transaction for that. Then just check the latest version number.", "group_id": 81, "id": 787213}, {"user_id": 3705, "stars": [], "topic_id": 20946, "date_created": 1303532759.4060769, "message": "Mulling over the problem of keeping a record of all revisions to a model. A blog post model is what I have in mind. It's largely textual and read mostly.", "group_id": 81, "id": 787206}, {"user_id": 594, "stars": [], "topic_id": 20946, "date_created": 1303532794.2346611, "message": "Check django-packages, there are a bunch of ways this has been implemented in the past.", "group_id": 81, "id": 787209}, {"user_id": 13912, "stars": [], "topic_id": 20946, "date_created": 1303559572.8607121, "message": "check out my reusable app django-audit-log https://github.com/Atomidata/django-audit-log", "group_id": 81, "id": 788544}, {"user_id": 13912, "stars": [], "topic_id": 20946, "date_created": 1303559727.6459501, "message": "optimistic locking is not so easy to implement. I saw someone tried to bolt-on pessimistic locking to django-audit-log, but I can't see the benefit of having pessimistic locking in a web app + I didn't like the solution", "group_id": 81, "id": 788549}, {"user_id": 23244, "stars": [], "topic_id": 20946, "date_created": 1303559392.3492711, "message": "I've used an archive flag pattern for a journaling system. When editing, I first make a deep copy of the object to be edited and set the archive flag on the copy, while also setting an edited_by and edited_at timestamp and a current_version foreign key to the original (now edited) object. Thus I can get the full version history by a single query ordered by edited_at for date ordering. The model manager is set to ignore all objects with the archive flag set unless specifically looking for them. The pattern should be usable for any model.", "group_id": 81, "id": 788537}, {"user_id": 13912, "stars": [], "topic_id": 20946, "date_created": 1303559896.257726, "message": "IMHO optimistic locking is something that should go into the ORM as the most sane method of implementing it is with SQL. Rails active-record has that feature.", "group_id": 81, "id": 788555}, {"user_id": 13912, "stars": [], "topic_id": 20946, "date_created": 1303560223.5275731, "message": "sql-alchemy has something like that too", "group_id": 81, "id": 788560}]