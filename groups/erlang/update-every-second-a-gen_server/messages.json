[{"user_id": 18775, "stars": [], "topic_id": 17541, "date_created": 1302067852.6488309, "message": "I am creating a behaviour as a gen_server, and i want it to receive messages to process, but also i want it to make a calculation each second AFTER the last message received. What i'm thinking is on creating a regular process with: receive after 1000 send_process_to_server(), loop end... I want to know if this is the best way, as i want to keep it as much OTP as possible...", "group_id": 21, "id": 555079}, {"user_id": 18775, "stars": [], "topic_id": 17541, "date_created": 1302068054.4934731, "message": "Damn, i don't know how i didn't see the \"timer\" module...\n\nNow i can create a timer to interval each second, and restart it each time i receive a normal message to process...", "group_id": 21, "id": 555109}, {"user_id": 18775, "stars": [], "topic_id": 17541, "date_created": 1302069231.3930061, "message": "Worked really nice, it ended up something like this:\n\ninit(State) ->\n    Timer = start_timer(),\n    {ok, {State, Timer}}.\n\nhandle_cast({tick}, AllState = {State, Timer}) ->\n    countdown(State),\n    {noreply, AllState};\nhandle_cast({othercall, Message}, {State, Timer}) ->\n    TimerNew = reset_timer(Timer),\n    NewState = other_call(Message),\n    {noreply, {NewState, TimerNew}}.\n\ntick(Pid) ->\n\tgen_server:cast(Pid, {tick}).\n\nstart_timer() ->\n\t{ok, Timer} = timer:apply_interval(1000, ?MODULE, tick, [self()]),\n\tTimer.\n\nrestart_timer(Timer) ->\n\ttimer:cancel(Timer),\n\tstart_timer().", "group_id": 21, "id": 555196}, {"user_id": 242, "stars": [], "topic_id": 17541, "date_created": 1302109120.30283, "message": "It's probably not relevant to this code snippet, but timer:*_interval can cause messages to pile up in your message queue if it ever takes > interval to handle the message.  You might also be interested in timer:send_* which will allow you to send a message directly to the process.  You can handle non-call/cast messages in handle_info.", "group_id": 21, "id": 561487}, {"user_id": 242, "stars": [], "topic_id": 17541, "date_created": 1302112105.1871901, "message": "Or you can use timer:(send/apply)_after and reschedule the operation after it is completed.", "group_id": 21, "id": 562108}, {"user_id": 18775, "stars": [], "topic_id": 17541, "date_created": 1302110991.2676971, "message": "Oh, that's a good point, very relevant for what i'm trying to do... Maybe i should generate a random cookie, so the timer passes me that cookie on each tick, and it must match my current cookie, if not, then it was a piled and deprecated message so i can discart it...", "group_id": 21, "id": 561779}, {"user_id": 242, "stars": [], "topic_id": 17541, "date_created": 1302112294.580246, "message": "You can also reschedule before you do your actual work, which means that for an operation taking > interval there will always be one message in the queue and work may begin again immediately.  Without knowing more about your specific application I can't really say for sure.", "group_id": 21, "id": 562150}, {"user_id": 18775, "stars": [], "topic_id": 17541, "date_created": 1302118814.4705081, "message": "So, no problem if it's not accurate", "group_id": 21, "id": 563759}, {"user_id": 18775, "stars": [], "topic_id": 17541, "date_created": 1302118803.0402939, "message": "it's a bidding application, need to decrement on each second, but dont need it to be precise, since each \"message\" will only set the time to:\n\ntime_in_secs = total_time_in_secs - (current_time_in_secs - initial_time_in_secs)", "group_id": 21, "id": 563756}, {"user_id": 24874, "stars": [], "topic_id": 17541, "date_created": 1302334302.027544, "message": "Try not to use the timer module, always use erlang:start_timer/3 and erlang:send_after/3 whenever possible.", "group_id": 21, "id": 600751}, {"user_id": 18775, "stars": [], "topic_id": 17541, "date_created": 1302361588.5127771, "message": "Is there a reason?", "group_id": 21, "id": 602578}, {"user_id": 24874, "stars": [], "topic_id": 17541, "date_created": 1303827663.282877, "message": "Also, maybe you find this thread useful: https://groups.google.com/group/erlang-programming/browse_thread/thread/1b4232ffeea6983?fwc=2", "group_id": 21, "id": 814864}, {"user_id": 24874, "stars": [], "topic_id": 17541, "date_created": 1303827617.1361461, "message": "It's just faster: http://www.erlang.org/doc/efficiency_guide/commoncaveats.html", "group_id": 21, "id": 814856}, {"user_id": 19202, "stars": [], "topic_id": 17541, "date_created": 1306488608.5074921, "message": "@hpcorona It is built-in (if I am reading you right). In handle_cast/call you can do {noreply, NewState, 1000} as the return which will make handle_info get a timeout message 1000ms after the last processing. It only happens *if no other message is received in the mean-time* though. If a new message arrives, it is reset and remember to also do it in all {noreply/reply, NewState, ...} returns.", "group_id": 21, "id": 1203012}]