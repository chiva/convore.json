[{"user_id": 21141, "stars": [], "topic_id": 17456, "date_created": 1302035533.7045741, "message": "I was talking with someone today who was describing what they were trying to do for a project.  They wanted to generate the possible set of matrices from known eigenvalues.  I don't often work with these types of things.  I see that numpy.linalg has the eigvals and eig functions but nothing to do the inverse which seems to be a much more complicated problem.  Anyone have any suggestions or pointers before I spend too much time relearning my linear algebra and trying to figure out a solution?", "group_id": 6727, "id": 546231}, {"user_id": 21506, "stars": [], "topic_id": 17456, "date_created": 1302081809.8313379, "message": "if it's a square matrix, the eigenvalues are just the diagonal elements.", "group_id": 6727, "id": 557206}, {"user_id": 10454, "stars": [], "topic_id": 17456, "date_created": 1302097891.11326, "message": "@squeezedlight, uh, no, they're not.", "group_id": 6727, "id": 559415}, {"user_id": 10454, "stars": [], "topic_id": 17456, "date_created": 1302098187.1496291, "message": "@jzmiller1, you can't generate *all* of them. There are infinitely many.", "group_id": 6727, "id": 559467}, {"user_id": 21141, "stars": [], "topic_id": 17456, "date_created": 1302107571.022603, "message": "Yes, I've been reading up on this problem and its actually pretty complex.  The matrix is a 7x7.  The diagonal elements are useful, the sum is the trace.", "group_id": 6727, "id": 561260}, {"user_id": 21141, "stars": [], "topic_id": 17456, "date_created": 1302107650.204145, "message": "@RobertKern Do you know of a good method I could use to generate a few? 10, maybe 100 at time?  I've struggled to find something.  Thanks for checking this conversation out tho.", "group_id": 6727, "id": 561266}, {"user_id": 10454, "stars": [], "topic_id": 17456, "date_created": 1302112098.1373391, "message": "Do you care how evenly they are distributed in the space? Do you need to restrict yourself to real matrices?", "group_id": 6727, "id": 562107}, {"user_id": 10454, "stars": [], "topic_id": 17456, "date_created": 1302115468.215342, "message": "Short answer, generate a random 7x7 matrix (np.random.standard_normal([7,7]) is best), maybe symmetrize it, find its eigenvectors, and then construct a matrix using those eigenvectors and your own eigenvalues: np.dot(v.H, eigvals * v)", "group_id": 6727, "id": 562846}, {"user_id": 10454, "stars": [], "topic_id": 17456, "date_created": 1302115591.3282959, "message": "[~]\n|1> import numpy as np\n\n[~]\n|2> A = np.random.standard_normal([7,7])\n\n[~]\n|3> B = np.dot(A.T, A)\n\n[~]\n|5> w,v = np.linalg.eigh(B)\n\n[~]\n|6> my_eigvals = np.arange(7,0,-1)\n\n[~]\n|7> M = np.dot(v.T, my_eigvals * v)\n\n[~]\n|8> np.linalg.eigvals(M)\narray([ 7.,  6.,  5.,  4.,  3.,  2.,  1.])\n", "group_id": 6727, "id": 562879}, {"user_id": 43883, "stars": [], "topic_id": 17456, "date_created": 1322416616.4356461, "message": "Generate a diagonal matrix D with the eigenvalues you want, generate a random orthogonal matrix Q. Then A = Q.T * D * Q has the desired eigenvalues. One of the many ways to generate a Q is to build a Householder matrix : Q = I - 2* u*u.T/dot(u,u) for some random (nonzero) vector u.", "group_id": 6727, "id": 2652654}]